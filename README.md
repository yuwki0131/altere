# README.md


## Core Architecture

* 編集モデル: バッファ/ポイント/マーク、リージョン、キルリング、レジスタ、マーカーの語彙と不変条件
* テキスト格納方式: ギャップバッファ / ロープ / ピーステーブル / COW+mmap（巨大ファイル・部分読み込み・低メモリを想定）
* Undo 体系: 線形 / 永続化（ファイル別ヒストリ）
* 検索・置換: インクリメンタル検索、正規表現エンジン（別途選定）、多バイト対応、ヒストリあり
* 同期モデル: 別途検討 (イベントループ（GUI/TUI共通）、非同期 I/O、キャンセル可能ジョブ、スレッド/タスク（GC との相互作用）)
* サブプロセス統合: 非同期プロセス
* ファイル監視: inotify/kqueue/FSEvents/ReadDirectoryChangesW、リロード/競合解決UI
* 信頼性: オートセーブ、バックアップ、クラッシュリカバリ（ジャーナル/スナップショット）

## 表示・レンダリング
* ターゲット: TTY（全端末）/ GUI（Wayland, X11, Windows, macOS）両対応か、どちらかに絞るか
* テキストレイアウト: HarfBuzz 文字整形、UAX #29（書記素クラスタ）、双方向（UAX #9）、合字・絵文字・IVS、禁則・折返し
* フォント: 等幅保証、CJK幅対応（East Asian Width）、絵文字フォント対応
* IME連携: fcitx5(最優先)/ibus/TSF/macOS IME、候補UI の被り防止、確定/未確定文字列の描画
* 速度最適化: 部分再描画、行キャッシュ、遅延レイアウト、超長行（minimap/virtual layout）対策
* アクセシビリティ(後回し事項): スクリーンリーダー（UIA/ATK/AX）、高コントラスト、フォーカス可視化

## 入力・キーバインド
* キーマップ階層: グローバル/メジャー/マイナー/ローカルの順で優先順位を設定のシャドーイング規則
* 連続キー（C-x C-f 等）対応
* OS/IME 衝突回避: Ctrl/Meta/Alt/Super、Wayland のグラブ、端末のキーコード差
* マウス/タッチ/トラックパッド対応: 矩形選択、マウス修飾、スムーススクロール

## 拡張性・言語内蔵
* 拡張言語: alisp:  Scheme系Lisp-1タイプの言語 (emacsにおけるelisp相当の役割を期待)
* API 設計: バッファ・ウィンドウ・プロセス・表示・ミニバッファ等の安定公開APIを用意 と内部 API の境界
* アドバイス/フック: before/after/around、メジャー/マイナー モードのライフサイクル
* パッケージ管理: レジストリ設計、署名/ハッシュ検証、依存解決、セマンティックバージョニング

## 言語機能連携(あとで検討)
* シンタックス: Tree-sitter 統合（インクリメンタル解析、ハイライト、構文ノード API）
* LSP: 非同期 RPC、キャンセル、並列ドキュメント（巨大プロジェクトでのスケジューリング）
* フォーマッタ/リンタ: 保存時フック、差分適用、部分フォーマット
* デバッガ（DAP）/ テストランナー: UI モデル、ステップ実行、ブレークポイント

## UI/UX 原則
* ミニバッファと補完: 候補絞り込み（ファジー/前方一致）、アクション選択、多段プロンプト
* ウィンドウ/フレーム: 分割・配置モデル、レイアウト保存、タブ/ワークスペース
* モードライン: 軽量で拡張可能、遅延評価、統計情報の収集コスト管理
* コマンド可観測性: M-x 的な一元化、最近使ったコマンド、キーワードからの発見性
* 既定のキーバインド哲学: Emacs 互換度 vs モダン化（CUA 併存）、学習コストとのバランス

## 国際化・互換・入出力
* 文字コード: UTF-8 基本、任意エンコーディング検出/保存（BOM, CP932 等）、EOL（LF/CRLF）
* 行末空白/タブ幅/インデントポリシー、EditorConfig 互換
* 改行と非常に長い行（log/JSON minify）の取り扱い、遅延ローディング
* クリップボード: X11 選択（PRIMARY/CLIPBOARD）/ Wayland / Windows / macOS 差異吸収

## 外部ツール連携: git 等 VCS（ブレーム/差分/ステージ/コミット）、grep/ripgrep(これもあとで検討)
* リモート・シェル
* TRAMP 風機能: SSH/SFTP/SSHFS/プロセスプロキシ、レイテンシ隠蔽と差分保存
* 内蔵ターミナル: 必要性、端末互換（xterm-kitty 等）、スクロールバックと検索

## セキュリティ・プライバシー
* 拡張の権限分離、署名・サンドボックス、ネットワークアクセスのユーザー同意
* テレメトリ方針: 完全オプトイン、最小化、匿名化、オフラインでの再現性

## テスト・品質・パフォーマンス (これもあとで連携)
* ベンチ: 編集・レンダリング・GC・巨大ファイル・超長行・LSP 同時負荷
* テスト: プロパティベース（バッファ不変条件）、ファズ（パーサ/レンダラ）、ゴールデンテスト（描画）
* プロファイリング: ホットパス特定（レンダ/入力/GC）、可視化（frame time）
* GC 設計: 世代別/アリーナ/インクリメンタル、タイピング遅延への影響最小化

## 配布・運用(これはやらない)
* ライセンス: GPL 互換性（Emacs 互換性をどこまで意識するか）
* ビルド/配布: Nixpkgs / Homebrew / winget / Flatpak、再現可能ビルド
* 設定配布: dotfiles、初期テンプレ、組織配布向けポリシー
* ドキュメント: 入門〜拡張 API、安定化ポリシー、マイグレーションガイド


## MVP方針

### まず実装する最小機能
* 高速テキストモデル（例: ピーステーブル）
* インクリメンタル描画（HarfBuzz＋部分再描画）
* キーマップ階層＋ミニバッファ＋M-x
* ミニバッファでexitと入力すると終了できるコマンド受付

## NextStep

### 拡張言語alispの実装

1つの拡張言語（Elisp 互換 or Lua など）とパッケージローダ

Tree-sitter ベースのハイライト

### 後回し候補

* TRAMP 互換の完全実装
* 内蔵ターミナル
* DAP（LSP だけ先に）
* 双方向/縦書きなど高度組版（まずは左→右に限定し安定化）

## 技術選定

* 言語: Rust（安全＋速度）でコア
* 環境はNixos, Wayland, Hyprlandで動作させることを最優先
